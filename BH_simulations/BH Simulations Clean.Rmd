---
title: "BH Simulations Clean"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```

# Step 1

Simulate data with Beverton-Holt model for 4 (or fewer) species with no environmental effect.

## Functions

Function for a single BH run. Calculating new populations with a for loop over i species for a single set of input populations and a single time step.
```{r function-BH}
BH.run <- function(num.species, N.0, lambda, alpha){
  N.1 <- numeric(length = num.species) # blank vector to be filled in with the for loop
  for(i in 1:num.species){
    comp.sum <- sum(alpha[,i]*N.0)
    N.1[i] <- N.0[i]*lambda[i] / (1 + comp.sum)
  }
  
  return(N.1)
}
```



### Single run with generic competition
```{r single-run}

num.species <- 4
num.interactions <- num.species^2
set.seed(23) # to keep it consistent while coding


# setting up blank vectors and matrices
N.0 <- rep.int(100, times=num.species) # initial populations/seeds all set at 100
lambda <- rpois(n = num.species, lambda = 4) # intrinsic growth
a.intra <- 0.01 # intraspecific competition
a.gen <- 0.001 # generic competitors

# setting up competition matrix with only generic and intraspecific
# leaving aside the strong competitor for now
alpha <- matrix(a.gen, nrow = num.species, ncol = num.species) 
diag(alpha) <- a.intra

lambda
BH.run(num.species, N.0, lambda, alpha)

```

### Single run with some strong competition interactions

Having some of the competition values vary from the generic. First one species that exerts stronger competition on all the rest. The way the function is written, each row in alpha is an acting species, and each column is the responding species (so a given value is the competitive effect of the row species on the column species).

I've also done this in a different way with pairs of competitors having stronger interactions with each other (for example, species #2 and species #3 are symmetrically strong competitors)

```{r strong-competitor}

num.species <- 4
num.interactions <- num.species^2
set.seed(23) # to keep it consistent while coding


# setting up blank vectors and matrices
N.0 <- rep.int(100, times=num.species) # initial populations/seeds all set at 100
lambda <- rpois(n = num.species, lambda = 4) # intrinsic growth
a.intra <- 0.01 # intraspecific competition
a.gen <- 0.001 # generic competitors
a.strong <- 0.005 # strong competitor

# setting up competition matrix with only generic and intraspecific
# leaving aside the strong competitor for now
alpha <- matrix(a.gen, nrow = num.species, ncol = num.species) 
diag(alpha) <- a.intra
strong.actor <- 3 # species that is strongly competitive
strong.response <- c(1, 2, 4) # species affected strongly by that competition
alpha[strong.actor, strong.response] <- a.strong # changing those competitive values

lambda
BH.run(num.species, N.0, lambda, alpha)

```


### Linear response of lambda to environment

Function for multiple BH runs where each run takes place in a different background environmental condition. Lambda coefficients are modified according to that background environmental condition and species' environmental response coefficient. Still a single time step, but with multiple runs from a single set of input lambda intrinsic growth rates and alpha competition coefficients. 

Inputs: 
- Data frame with columns of species, lambda, lambda.env response, and alpha columns for each species (so a 4 species run would have four alpha columns labeled 'alpha.1', 'alpha.2', etc)
- Number of runs
- Number of time steps (currently only coded to do a single time step)
- Mean and sd for starting populations which are drawn from a normal distribution
- Environmental conditions for each run
- Demographic heterogeneity value which is used as the sd in draws from a normal distribution with a mean of 0 and adds stochasticity to the lambda value used for each species. Defaults to 0, which is no added stochasticity. 

Calls the single BH run function above. 

```{r function-BH-env}
BH.env <- function(df.in, n.runs, n.steps, p.start.mean, p.start.sd, env, dem.het = 0)
{
  n.species <- length(df.in$species)
  species <- rep(factor(1:n.species), times = n.runs*(n.steps+1))
  run <- rep(1:n.runs, each = n.species*(n.steps+1))
  time <- rep(rep(0:n.steps, each = n.species), times = n.runs)
  pop <- rep(-100, times = n.species*(n.steps+1)*n.runs) # making this a negative number instead of 0 so we can easily troubleshoot
  run.env <- rep(env, each = n.species*(n.steps+1)) # matching the input env conditions to each run
  
  df.out <- data.frame(species, run, run.env, time, pop)
  
  
  for(r in 1:n.runs){
    # where to store the data
    start.rows <- df.out %>% 
      with(run == r & time == 0) %>%
      which()
    end.rows <- df.out %>% 
      with(run == r & time == 1) %>%
      which()
    
    # initial populations
    start.pop <- as.integer(rnorm(n.species, 
                                  mean = p.start.mean, 
                                  sd = p.start.sd))
    start.pop[start.pop < 0] <- 0 # set negative numbers to zero
    
    df.out$pop[start.rows] <- start.pop
    
    lambda.het <- rnorm(n.species, mean = 0, sd = dem.het) # add demographic stocasticity
    
    lambda <- df.in$lambda.mean + df.in$lambda.env*env[r] + lambda.het
    alpha <- df.in %>% select(starts_with('alpha'))
    
    df.out$pop[end.rows] <- BH.run(n.species, start.pop, lambda, alpha)
  }
  return(df.out)
}

```


Running the function: set up input parameters
```{r multiple-env-input}

num.species <- 10
num.runs <- 50
time.steps <- 1 # currently only designed for one time step, would need a nested for loop below to do otherwise
env.variation <- 1 # variation of environmental condition among plots(sd of normal distribution)
# (0 = no environmental variaiton, 1 = some)

env.response <- 2 # growth rate - variation in the responses of species to their environment 
# (sd for draw, try 2 for decently strong environmental responses)
stochasticity <- 0.2 # growth rate - magnitude of demographic heterogeneity try 0.2 for moderate heterogeneity

a.intra <- 0.01 # intraspecific competition
a.gen.mean <- 0.001 # generic competitors mean 

a.gen.variation <- 0.0003 # variation in the generic species from mean (0 for none, 0.0003 for some variation)
a.diff.num.draw <- 2 # lambda for poisson draw of how many species are non-generic competitors
a.diff.variation <- 0.5 # how strongly those competitors should vary from the generic 0.001 
# (rate in draws from exponential distribution, 
# the smaller the number the stronger the non-generic competitors are likely to be, 
# although this can also yield factors of < 1 which creates weak non-generic competitors)

# parameters for starting population draws from a normal distribution
pop.start.mean <- 80
pop.start.sd <- 100 

```


Running the function: drawing values for the species and plots and running the simulation for a given number of runs (can think of these as plots sampled). *Currently breaks if a.diff.num (number of non-generic species) draws as 0*
```{r env-running}
# environmental condition in each run (run = population sampled)
env.condition <- rnorm(n = num.runs, mean = 0, sd = env.variation)

# setting up blank vectors and matrices
lambda.mean <- runif(n = num.species, min = 1, max = 5) # intrinsic growth
lambda.env <- rnorm(n = num.species, mean = 0, sd = env.response) # environmental response

# setting up competition matrix
alphas.generic <- rnorm(num.species^2, mean = a.gen.mean, sd = a.gen.variation)
alpha <- matrix(alphas.generic, nrow = num.species, ncol = num.species) # filling with all generic values

a.diff.num <- rpois(n = 1, lambda = a.diff.num.draw) # number of non-generic species
a.diff <- sample(1:num.species, a.diff.num) # ids of non-generic species

# filling in alphas for non-generic species
for(i in 1:a.diff.num){
  all.species <- 1:num.species
  competitor <- a.diff[i]
  responders <- all.species[!(all.species %in% competitor)]
  comp.diff <- rexp(1, a.diff.variation)
  alpha[competitor, responders] <- alpha[competitor, responders] * comp.diff
#  print(c(competitor, comp.diff)) this was for testing
}

# filling in alphas for intraspecific variaiton
diag(alpha) <- a.intra


# input dataframe of coefficients
df.coef <- data.frame(species = factor(1:num.species), lambda.mean, lambda.env, alpha) %>%
  rename_with(.,~gsub("X","alpha.", .x, fixed = TRUE))

# running the simulation
df.result <- BH.env(df.in = df.coef, 
                    n.runs = num.runs, n.steps = time.steps, 
                    p.start.mean = pop.start.mean, p.start.sd = pop.start.sd, 
                    env = env.condition,
                    dem.het = stochasticity)

```

Storing the output
```{r env-storing}
write.csv(df.coef, file = "parameters_4b_env_dem.csv")
write.csv(df.result, file = "simulation_4b_env_dem.csv")

```



Visualization for showing the output -- useful for checks
```{r env-plotting-output}

df.result.wide <- df.result %>%
  pivot_wider(names_from = time, names_prefix = "time.", values_from = pop) %>%
  left_join(df.coef, by = 'species')

# View(df.result.wide) # wide format with initial coefficients included

df.result.wide$diff <- df.result.wide$time.1 - df.result.wide$time.0
 
ggplot(df.result.wide, aes(x = run.env, y = diff, color = species)) + 
  geom_point() + 
  geom_smooth(method = 'lm', se = FALSE)
  
df.coef

```
